## 개발 중의 고민거리 끄적끄적

### Index
 * 개발 고민
    * [if~else, switch 바꿔 보기](#if-~-else,-switch를-좀-더-깔끔하게)
    * [Request data 없는 Dto field 값 주입](#Spring-Request-시에-특정-DTO-field를-초기화)
    * [비동기 Threadlocal 핸들링](#Async-Worker-Process에서-ThreadLocal-변수-핸들링)

---
#### if ~ else, switch를 좀 더 깔끔하게

- Condition State 별로 적절한 메서드를 호출 하거나 객체를 생성
    - if ~ else가 틀린 건 아니나 항상 개발하면 확장 / 축소와 마주하게 됨
    - if ~ else의 구문을 건드려야한다는 것 비교 컨디션에 따라서 depth 깊이가 길어진다는 점 -> 즉, 실수가 일어나는 포인트
    - TEST 복잡도와 커버리지도 급격하게 늘어나는 것도 문제
    - 컨디션 상태를 고정 시키고 상태에 따라서 즉시 해당 action을 매치 시킨 다면?
    - 열거형 enum을 활용 해보자 (상수처럼 쓰고 싶다)
    ```java
    enum TypeComp {
        // input 값이 A면 1을 리턴하는 메서드를 호출하는 세트를 TypeA라는 열거형 상수로 관리
        TypeA("A", (input) -> 1),
        TypeB("B", (input) -> 2),
        TypeC("C", (input) -> 3);

        private final Function<String, Integer> operator;

        TypeComp(String conditionKey, Function<String, Integer> returnCodeFunc) {
            this.operator = returnCodeFunc;
            // name reflection
            try {
                // name을 reflect로 입맛에 맞게 필드를 살짝 바꾼다
                // TypeA -> A 로 name이 바뀐다
                Field enumName = getClass().getSuperclass().getDeclaredField("name");
                enumName.setAccessible(true);
                enumName.set(this, name);
            } catch (Exception e) {
                log.error("### enum field accessible error");
            }
        }

        public Integer executeOperator(String conditionKey) {
            return this.operator.apply(conditionKey);
        }
    }

    ```
- Step Chains (compare -> apply 반복)
    - chain이 되는 객체를 하나 더 받아서 처리하기만 하면 됨
    - 추가로 전체 열거형에 대해서 컨디션 비교하고 true면 chain 적용 형식으로도 구현이 가능
    ```java
    ChainEnums.values().foreach(chain -> chain.executeOperator(condition, originalChain));
    ```

#### Spring Request 시에 특정 DTO field를 초기화

- reqeust 등록 및 수정 시 Json DTO를 중에 입력 값은 주지 않지만 DTO에 후처리로 필드를 업데이트를 하거나 하는 경우가 있다
- 대표적으로 세션 정보 (POST는 등록자, PUT이면 수정자)
- 항상 컨트롤러 처음에 세션 컨텍스트를 조회하고 DTO에 집어넣는 걸 반복 코드로 집어넣는게 불편함
- 이걸 신경 쓰지 않고 자동화(?)하는 방법을 고민하는 것에 출발함
- **위 목적을 달성 위한 수단과 방법**
    - When : Controller가 호출 되기 전
    - What : 파라미터의 특정 객체(request DTO), 주입 할 그 객체의 필드
    - How : Spring AOP, Annotation

- Annotation을 통해 클라이언트가 제공해주지 않는 데이터를 주입할 객체 타입, 객체의 필드 이름을 정의
    - code
    ```java
    @Target({ ElementType.METHOD, ElementType.PARAMETER })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface SessionUser {

        /**
        * 값을 주입할 필드
        * @return {@link String}
        */
        String targetField() default "registUser";

        /**
        * 주입할 필드가 존재하는 클래스 타입
        * @return {@link Class<?>}
        */
        Class<?> dtoClass();

        /**
        * 필드 주입 제공 클래스
        * @deprecated 제공 클래스를 받아 처리 했으나 관심사 처리로 이동 <br>
        * {@link FieldInjectFunction}를 구현한 프로바이더 클래스를 가져온다 <br>
        * {@link SessionUser} annotation을 의존한다. <br>
        * Dto에 세션 유저를 Dto 필드에 집어 넣는 클래스가 Default
        * @return UserInjectFunction 구현체
        */
        @Deprecated
        Class<? extends FieldInjectFunction> injectProvider() default DtoSessionUserInjectFunction.class;
    }
    ```
- AOP를 통해 Pointcut의 Controller & Annotation(주입 전용)을 관심사 분리
    
    - code
    ```java
    /**
    * 관심사는 컨트롤러, SessionUser 어노테이션이 달려있는 메서드
    * 해당 파라미터의 어노테이션의 실제 정의된 정보를 가져와서 joinpoint의 실제 파라미터 중 맞는 객체를 꺼내온 다음 주입 처리
    * 주입처리는 보통 자바 리플렉션
    */
    @Before("onSessionConvert() && @annotation(sessionUser)")
    public void convertSessionUser(JoinPoint joinPoint, SessionUser sessionUser)
    ```

- 다른 방법?
    
    - AbstractProcessor를 통한 직접적인 어노테이션 프로세스를 구현 하는 방법 (spring framework 안 쓰면 고려)

- 어노테이션을 통한 관심사 분리 -> 핸들링 기능을 통해 여러가지로 활용이 될 수 있다. 개인적으로 쓰고 있는 건 메서드 로깅, API 호출 후 이벤트 메시지 (이메일 또는 푸시 메시지)로 활용 하였다.

#### Async Worker Process에서 ThreadLocal 변수 핸들링
- 여러 API 요구사항 중에 특정 상황에서 발생하는데 보통 Request 한번에 비슷한 Task를 병렬로 실행하고 결과를 Response해야하는 경우가 대표적 (**Blocking / Asynchronous**)
- 전체 요청/응답 흐름은 동기적이나 부분적인 병렬처리는 비동기
- 이 상황에서 가장 문제가 되는 부분이 ThreadLocal 변수를 사용하는 영역이다.
- Threadlocal은 말 그대로 쓰레드 별로 변수를 독립적으로 가질 수 있게 하는 방법인데 반대로 생각하면 스레드 끼리 ThreadLocal 변수가 공유가 되지 않는다는 말
- Spring의 Context 데이터는 거의 모두 Threadlocal 변수
- 만약에 병렬 처리에서 Context 정보가 필요하면 요청/응답 스레드와 별도인 executor를 만들어서 사용하기 때문에 당연하게도 Context 데이터가 없다.
- 그래서 요청/응답 스레드의 Context 변수를 스레드에 사본을 전달해야한다
- **Concept**
    ```java
    ThreadPoolExecutor executor = new ThreadPoolTaskExecutor();

    // 내가 병렬로 처리할 로직
    Runnable work = () -> {
        //...bussiness logic
    }

    // 이로직을 실행하기 전에 Threadlocal 변수를 넘겨주는 데코레이터
    Runnable injectDecorator = () -> {
        HttpSession session = ContextUtils.getSession();
        // 실제 이 영역 부턴 executor 영역
        return () -> {
            ContextUtils.setSession(session);
            try {
                work.run();
            }
            catch(Exception e) {
                //..exception
            }
            finally {
                // Threadlocal 변수 제거
                ContextUtils.cleanUp();
            }            
        }
    }

    // 실행
    executor.execute(injectDecorator);
    ```
- 물론 void면 Runnable이지만 리턴 값이 있으면 Callable, 파라미터가 있거나 리턴형에 따라서 얼마든지 다른걸 구현해도 된다.

