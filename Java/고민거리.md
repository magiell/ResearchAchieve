### 개발 중의 고민거리 끄적끄적

#### if ~ else, switch를 좀 더 깔끔하게

- Condition State 별로 적절한 메서드를 호출 하거나 객체를 생성
    - if ~ else가 틀린 건 아니나 항상 개발하면 확장 / 축소와 마주하게 됨
    - if ~ else의 구문을 건드려야한다는 것 비교 컨디션에 따라서 depth 깊이가 길어진다는 점 -> 즉, 실수가 일어나는 포인트
    - TEST 복잡도와 커버리지도 급격하게 늘어나는 것도 문제
    - 컨디션 상태를 고정 시키고 상태에 따라서 즉시 해당 action을 매치 시킨 다면?
    - 열거형 enum을 활용 해보자 (상수처럼 쓰고 싶다)
    ```java
    enum TypeComp {
        // input 값이 A면 1을 리턴하는 메서드를 호출하는 세트를 TypeA라는 열거형 상수로 관리
        TypeA("A", (input) -> 1),
        TypeB("B", (input) -> 2),
        TypeC("C", (input) -> 3);

        private final Function<String, Integer> operator;

        TypeComp(String conditionKey, Function<String, Integer> returnCodeFunc) {
            this.operator = returnCodeFunc;
            // name reflection
            try {
                // name을 reflect로 입맛에 맞게 필드를 살짝 바꾼다
                // TypeA -> A 로 name이 바뀐다
                Field enumName = getClass().getSuperclass().getDeclaredField("name");
                enumName.setAccessible(true);
                enumName.set(this, name);
            } catch (Exception e) {
                log.error("### enum field accessible error");
            }
        }

        public Integer executeOperator(String conditionKey) {
            return this.operator.apply(conditionKey);
        }
    }

    ```
- Step Chains (compare -> apply 반복)
    - chain이 되는 객체를 하나 더 받아서 처리하기만 하면 됨
    - 추가로 전체 열거형에 대해서 컨디션 비교하고 true면 chain 적용 형식으로도 구현이 가능
    ```java
    ChainEnums.values().foreach(chain -> chain.executeOperator(condition, originalChain));
    ```

#### Spring Request 시에 특정 DTO field를 초기화

- reqeust 등록 및 수정 시 Json DTO를 중에 입력 값은 주지 않지만 DTO에 후처리로 필드를 업데이트를 하거나 하는 경우가 있다
- 대표적으로 세션 정보 (POST는 등록자, PUT이면 수정자)
- 항상 컨트롤러 처음에 세션 컨텍스트를 조회하고 DTO에 집어넣는 걸 반복 코드로 집어넣는게 불편함
- 이걸 신경 쓰지 않고 자동화(?)하는 방법을 고민하는 것에 출발함
- **위 목적을 달성 위한 수단과 방법**
    - When : Controller가 호출 되기 전
    - What : 파라미터의 특정 객체(request DTO), 주입 할 그 객체의 필드
    - How : Spring AOP, Annotation

- Annotation을 통해 클라이언트가 제공해주지 않는 데이터를 주입할 객체 타입, 객체의 필드 이름을 정의
    - code
    ```java
    @Target({ ElementType.METHOD, ElementType.PARAMETER })
    @Retention(RetentionPolicy.RUNTIME)
    public @interface SessionUser {

        /**
        * 값을 주입할 필드
        * @return {@link String}
        */
        String targetField() default "registUser";

        /**
        * 주입할 필드가 존재하는 클래스 타입
        * @return {@link Class<?>}
        */
        Class<?> dtoClass();

        /**
        * 필드 주입 제공 클래스
        * @deprecated 제공 클래스를 받아 처리 했으나 관심사 처리로 이동 <br>
        * {@link FieldInjectFunction}를 구현한 프로바이더 클래스를 가져온다 <br>
        * {@link SessionUser} annotation을 의존한다. <br>
        * Dto에 세션 유저를 Dto 필드에 집어 넣는 클래스가 Default
        * @return UserInjectFunction 구현체
        */
        @Deprecated
        Class<? extends FieldInjectFunction> injectProvider() default DtoSessionUserInjectFunction.class;
    }
    ```
- AOP를 통해 Pointcut의 Controller & Annotation(주입 전용)을 관심사 분리
    
    - code
    ```java
    /**
    * 관심사는 컨트롤러, SessionUser 어노테이션이 달려있는 메서드
    * 해당 파라미터의 어노테이션의 실제 정의된 정보를 가져와서 joinpoint의 실제 파라미터 중 맞는 객체를 꺼내온 다음 주입 처리
    * 주입처리는 보통 자바 리플렉션
    */
    @Before("onSessionConvert() && @annotation(sessionUser)")
    public void convertSessionUser(JoinPoint joinPoint, SessionUser sessionUser)
    ```

- 다른 방법?
    
    - AbstractProcessor를 통한 직접적인 어노테이션 프로세스를 구현 하는 방법 (spring framework 안 쓰면 고려)

- 어노테이션을 통한 관심사 분리 -> 핸들링 기능을 통해 여러가지로 활용이 될 수 있다. 개인적으로 쓰고 있는 건 메서드 로깅, API 호출 후 이벤트 메시지 (이메일 또는 푸시 메시지)로 활용 하였다.

#### AWS ECS Service에서 컨테이너의 포트를 2개 이상 열어보자

- 보통 멀티 컨테이너 환경에서 같은 도메인으로 묶을 경우 Load balancer를 앞에 달아 놓는데 아마존 콘솔 웹페이지에서는 해당 로드 밸런서 설정에서 컨테이너 포트는 단 하나만 연결 할 수 있다.

- 예를 들어 API서버 프로토콜 HTTP/1.1 :80 하나에 추가적으로 RPC(GRPC) 통신을 위해 HTTP/2 :8080을 추가로 띄운다고 가정하면 모두 로드밸런서에 달아야하나 불가능 함

- 콘솔이 안되니 **aws-cli**
    
    - command (요렇게 하면 서비스 생성에 대한 스켈레톤 스펙을 얻을 수 있다)
    ```bash
    aws ecs create-service --generate-cli-skeleton > create-service-skeleton.json
    ```
    - point (로드밸런서 설정이 일단 List니 설정이 되긴 되는구나)
    ```vim
    "loadBalancers": [
        {
            "targetGroupArn": "",
            "loadBalancerName": "",
            "containerName": "",
            "containerPort": 0
        }
    ],
    ```
    - sample (컨테이너 정의에서 사용되는 포트를 매치 시킨다)
    ```vim
    "loadBalancers": [
        {
            "targetGroupArn": "arn:aws:elasticloadbalancing:<Region>:<Account>:targetgroup/<targetGroupName>/<UNIQUE>",
            "containerName": "api_container",
            "containerPort": 80
        },
        {
            "targetGroupArn": "arn:aws:elasticloadbalancing:<Region>:<Account>:targetgroup/<targetGroupName>/<UNIQUE>",
            "containerName": "api_container",
            "containerPort": 10080
        }
    ]
    ```
    - execute
    ```bash
    aws ecs create-service --cli-input-json file://<작성파일명>.json --region <리전>
    ```


